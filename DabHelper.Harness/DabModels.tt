<#
    var connectionString = @"Data Source=(localdb)\MSSQLLocalDB;Initial Catalog=SampleDb;Integrated Security=True;Connect Timeout=60;Encrypt=False;TrustServerCertificate=False;ApplicationIntent=ReadWrite;MultiSubnetFailover=False";
#>
<#@ template    language    ="C#" #>
<#@ assembly    name        ="System.Core" #>
<#@ import      namespace   ="System.Linq" #>
<#@ import      namespace   ="System.Text" #>
<#@ assembly    name        ="System.Data" #>
<#@ import      namespace   ="System.Data" #>
<#@ import      namespace   ="System.Data.SqlClient" #>
<#@ import      namespace   ="System.Collections.Generic" #>
<#@ import      namespace   ="System.Collections" #>
<#@ assembly    name        ="System.Text.RegularExpressions" #>
<#@ import      namespace   ="System.Text.RegularExpressions" #>
<#@ output      extension   =".g.cs" #>
// more info at https://aka.ms/dab

using System;
using System.Diagnostics;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.ComponentModel.DataAnnotations.Schema;
using System.Text.Json.Serialization;

namespace Models
{
    public abstract class Poco { /* TODO */ }
}

<#
    var Cache = GetCache(connectionString);
    foreach (var schema in Cache.Select(x => x.Schema).Distinct()) { 
        var objects = Cache.Where(x => x.Schema == schema).Select(x => new 
            { 
                x.Name, 
                SafeName = Safe(x.Name),
                x.Type,
                Parameters = x.Params
                    .Zip(x.ParamNetTypes, (n, t) => new { Name = n, Type = t })
                    .OrderBy(z => z.Name),
                Columns = x.ColNames
                    .Zip(x.ColNetTypes, (n, t) => new { Name = n, Type = t })
                    .Zip(x.ColIsKey, (z, k) => new { z.Name, z.Type, IsKey = k })
                    .Zip(x.ColIsComputed, (z, c) => new { z.Name, z.Type, z.IsKey, IsComputed = c, JsonName = GetJsonName(z.Name), SafeName = Safe(z.Name) })
                    .OrderBy(z => z.IsKey).ThenBy(z => z.IsComputed),
            }).OrderBy(x => x.Type);
#>
namespace Models.<#= schema #>
{
<#
    // looping through tables, views, procs
    foreach (var dbo in objects) 
    { 
        // building the debugger display string
        var keys = dbo.Columns.Where(x => x.IsKey).Select(x => $"{x.Name} = {{{x.Name}}}");
        var parameters = dbo.Parameters.Select(x => $"{x.Name} = {{Parameters.{x.Name}}}");
        var display = string.Join(", ", keys.Union(parameters));
        display = (display.Length == 0) ? "keyless" : display;
#>
    [DebuggerDisplay("<#= schema #>.<#= dbo.Name #> (<#=display#>) [<#=dbo.Type#>]")]
    public class <#= Safe(dbo.Name) #> : Poco 
    {
    <#
        // looping through columns
        foreach (var column in dbo.Columns) 
    {#>
    <#if (column.IsKey) 
    {#>[Key]
        <#}#><#if (column.IsComputed) {#>[ReadOnly(true)]
        <#}#><#if (column.JsonName != column.SafeName) { #>[JsonPropertyName("<#=column.JsonName#>")]
        <#}#>public <#=column.Type#> <#=column.SafeName#> { get; set; } = default!;

    <#}
        // this section is only valid for procedures
        if (dbo.Parameters.Where(x => x.Name != "").Any()) 
        {#>    public ParameterInfo Parameters { get; set; } = new();
        public class ParameterInfo
        {
        <#
            // looping through parameters
            foreach (var p in dbo.Parameters) {#>    public <#=p.Type#> <#=Safe(p.Name)#> { get; set; } = default!;
        <#}#>
}
    }
<#} else {#>}
<#}#>

<#}#>
}<#}#><#+

string GetJsonName(string name)
{
    string result = Regex.Replace(name, @"(\p{Lu})", "-$1");
    result = Regex.Replace(result, @"[^\w]", "-");
    result = result.Trim('-', '[', ']', '.', ' ').ToLower().Replace(" ", "-");
    return Regex.Replace(result, @"-+", "-");
}

string Safe(string name)
{
    string safeName = Regex.Replace(name, @"\W+", " ");
    safeName = Regex.Replace(safeName, @"\b(\w)(\w*)", match => match.Groups[1].Value.ToUpper() + match.Groups[2].Value);
    return "@" + new string(safeName.Where(char.IsLetterOrDigit).ToArray());
}

IEnumerable<(string Schema, string Name, string @Type, string[] Params, string[] ParamSqlTypes, string[] ParamNetTypes, string[] ColNames, string[] ColSqlTypes, string[] ColNetTypes, bool[] ColIsKey, bool[] ColIsComputed)> GetCache(string connectionString)
{
    var connection = new SqlConnection(connectionString);
    connection.Open();

    var command = new SqlCommand(GetSql(), connection);
    using (var reader = command.ExecuteReader(CommandBehavior.CloseConnection))
    {
        while (reader.Read())
        {
            var schema = reader["schema_name"].ToString();
            var name = reader["object_name"].ToString();
            var type = reader["object_type"].ToString();
            var @params = reader["parameter_names"]?.ToString().Split(',');
            var paramSqlTypes = reader["parameter_sql_types"]?.ToString().Split(',');
            var paramNetTypes = reader["parameter_net_types"]?.ToString().Split(',');
            var colNames = reader["column_names"].ToString().Split(',');
            var colSqlTypes = reader["column_sql_types"].ToString().Split(',');
            var colNetTypes = reader["column_net_types"].ToString().Replace("string?", "string").Split(',');
            var colIsKey = reader["primary_key"].ToString().Split(',').Select(x => bool.Parse(x)).ToArray();
            var colIsComputed = reader["is_computed"].ToString().Split(',').Select(x => bool.Parse(x)).ToArray();

            yield return (schema, name, type, @params, paramSqlTypes, paramNetTypes, colNames, colSqlTypes, colNetTypes, colIsKey, colIsComputed);
        }
    }
}

string GetSql() => """
;WITH types AS 
(    
  SELECT DISTINCT system_type_id,  
    CASE   
      WHEN system_type_id IN (34, 35, 99, 173, 165, 167, 175, 231, 239) THEN 'string'    
      WHEN system_type_id IN (36, 189) THEN 'Guid'    
      WHEN system_type_id IN (48) THEN 'byte'    
      WHEN system_type_id IN (52) THEN 'short'   
      WHEN system_type_id IN (56) THEN 'int'
      WHEN system_type_id IN (58, 61) THEN 'DateTime' 
      WHEN system_type_id IN (59, 62, 106, 108, 122) THEN 'decimal'  
      WHEN system_type_id IN (60, 127) THEN 'double'  
      WHEN system_type_id IN (98) THEN 'object'  
      WHEN system_type_id IN (104) THEN 'bool'   
      WHEN system_type_id IN (241) THEN 'Xml'    
      ELSE 'unknown'    
    END AS net_type  
  FROM sys.types  
)    
, procedures AS
(    
  SELECT  
    s.name AS schema_name,  
    p.name AS object_name,  
    STRING_AGG(REPLACE(d.name, '@', ''), ',') AS parameter_names,   
    STRING_AGG(t.name, ',') AS parameter_sql_types,  
    STRING_AGG(CONCAT(ttypes.net_type, CASE WHEN t.is_nullable = 1 THEN '?' END), ',') AS parameter_net_types 
  FROM sys.procedures p  
  JOIN sys.schemas s ON p.schema_id = s.schema_id 
  LEFT JOIN sys.parameters d ON p.object_id = d.object_id AND d.parameter_id > 0
  LEFT JOIN sys.types t ON d.system_type_id = t.system_type_id   
  LEFT JOIN types AS ttypes ON ttypes.system_type_id = t.system_type_id    
  WHERE p.is_ms_shipped = 0   
  GROUP BY s.name, p.name
)    
SELECT    
  p.schema_name,  
  p.object_name,  
  'procedure' AS object_type,  
  p.parameter_names,
  p.parameter_sql_types,
  p.parameter_net_types,
  STRING_AGG(r.name, ',') AS column_names,
  STRING_AGG(TYPE_NAME(r.system_type_id), ',') AS column_sql_types,    
  STRING_AGG(CONCAT(rtypes.net_type, CASE WHEN r.is_nullable = 1 THEN '?' END), ',') AS column_net_types,   
  STRING_AGG('false', ',') AS primary_key,   
  STRING_AGG('true', ',') AS is_computed    
FROM procedures AS p
CROSS APPLY sys.dm_exec_describe_first_result_set(N'EXEC ' + QUOTENAME(p.schema_name) + '.' + QUOTENAME(p.object_name), NULL, 0) AS r 
JOIN types AS rtypes ON rtypes.system_type_id = r.system_type_id 
GROUP BY 
  p.schema_name,  
  p.object_name,  
  p.parameter_names,
  p.parameter_sql_types,
  p.parameter_net_types
 
UNION
    
SELECT
  s.name AS schema_name,
  t.name AS object_name,
  'table' AS object_type,
  NULL, NULL, NULL,
  STRING_AGG(c.name, ',') AS column_names,
  STRING_AGG(TYPE_NAME(c.system_type_id), ',') AS column_sql_types,
  STRING_AGG(CONCAT(ctypes.net_type, CASE WHEN c.is_nullable = 1 THEN '?' END), ',') AS column_net_types,    
  STRING_AGG(CASE WHEN ic.column_id IS NOT NULL THEN 'true' ELSE 'false' END, ',') AS primary_key,
  STRING_AGG(CASE WHEN cc.name IS NOT NULL THEN 'true' ELSE 'false' END, ',') AS is_computed
FROM sys.tables t
JOIN sys.schemas s ON t.schema_id = s.schema_id
JOIN sys.columns c ON t.object_id = c.object_id
JOIN types AS ctypes ON ctypes.system_type_id = c.system_type_id 
LEFT JOIN sys.indexes i ON i.object_id = t.object_id AND i.is_primary_key = 1
LEFT JOIN sys.index_columns ic ON ic.object_id = t.object_id AND ic.index_id = i.index_id AND ic.column_id = c.column_id
LEFT JOIN sys.computed_columns cc ON c.object_id = cc.object_id AND c.column_id = cc.column_id
WHERE c.graph_type IS NULL 
GROUP BY 
  s.name,
  t.name

UNION
 
SELECT    
  s.name AS schema_name,    
  v.name AS object_name,    
  'view' AS object_type,    
  NULL, NULL, NULL,    
  STRING_AGG(c.name, ',') AS column_names,
  STRING_AGG(TYPE_NAME(c.system_type_id), ',') AS column_sql_types,
  STRING_AGG(CONCAT(ctypes.net_type, CASE WHEN c.is_nullable = 1 THEN '?' ELSE '' END), ',') AS column_net_types,    
  STRING_AGG('false', ',') AS primary_key,
  STRING_AGG(CASE WHEN cc.name IS NOT NULL THEN 'true' ELSE 'false' END, ',') AS is_computed
FROM sys.views v    
JOIN sys.schemas s ON v.schema_id = s.schema_id   
JOIN sys.columns c ON v.object_id = c.object_id   
JOIN types AS ctypes ON ctypes.system_type_id = c.system_type_id 
LEFT JOIN sys.key_constraints pkc ON c.object_id = pkc.parent_object_id AND c.column_id = pkc.unique_index_id 
LEFT JOIN sys.computed_columns cc ON c.object_id = cc.object_id AND c.column_id = cc.column_id
GROUP BY 
  s.name,
  v.name 
""";
#>