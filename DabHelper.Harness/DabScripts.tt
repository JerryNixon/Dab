<#
    var connectionString = @"Data Source=(localdb)\MSSQLLocalDB;Initial Catalog=SampleDb;Integrated Security=True;Connect Timeout=60;Encrypt=False;TrustServerCertificate=False;ApplicationIntent=ReadWrite;MultiSubnetFailover=False";
#>
<#@ template    language    ="C#" #>
<#@ assembly    name        ="System.Core" #>
<#@ import      namespace   ="System.Linq" #>
<#@ import      namespace   ="System.Text" #>
<#@ assembly    name        ="System.Data" #>
<#@ import      namespace   ="System.Data" #>
<#@ import      namespace   ="System.Data.SqlClient" #>
<#@ import      namespace   ="System.Collections.Generic" #>
<#@ import      namespace   ="System.Collections" #>
<#@ assembly    name        ="System.Text.RegularExpressions" #>
<#@ import      namespace   ="System.Text.RegularExpressions" #>
<#@ output      extension   =".g.txt" #>

del dab-config.json
dab init --config "dab-config.json" --graphql.disabled "true" --host-mode development --database-type mssql --set-session-context true --connection-string "<#=connectionString#>"

<#
    var Cache = GetCache(connectionString);
    var schemaCount = Cache.Select(x => x.Schema).Distinct().Count();

    var tables = Cache.Where(x => x.Type == "table" || x.Type == "view").Select(x => new 
        { 
            Label = (schemaCount == 1) ? x.Name : $"{x.Schema}.{x.Name}",
            Source = $"{x.Schema}.{x.Name}",
            Type = x.Type,
            Rest = ((schemaCount == 1) ? x.Name : $"{x.Schema}.{x.Name}").ToLower(),
            Keys = string.Join(",", x.ColNames.Zip(x.ColIsKey, (n, k) => new { Name = n, IsKey = k}).Where(x => x.IsKey).Select(x => x.Name)),
            Map = string.Join(",", x.ColNames.Select(x => $"{x}:{GetJsonName(x)}")),
        });
    foreach (var table in tables)
    {
        var keys = string.IsNullOrEmpty(table.Keys) ? string.Empty : table.Keys;
        keys = string.IsNullOrEmpty(table.Keys) ? string.Empty : "--source.key-fields \"" + table.Keys + "\"";
#>
dab add "<#=table.Label#>" --config "dab-config.json" --source "<#=table.Source#>" --source.type "<#=table.Type#>" <#=keys#> --rest "<#=table.Rest#>" --permissions "anonymous:read"
dab update "<#=table.Label#>" --config "dab-config.json" --map "<#=table.Map#>"

<#}
    var procs = Cache.Where(x => x.Type == "procedure").Select(x => new 
        { 
            Label = (schemaCount == 1) ? x.Name : $"{x.Schema}.{x.Name}",
            Source = $"{x.Schema}.{x.Name}",
            Type = x.Type,
            Rest = ((schemaCount == 1) ? x.Name : $"{x.Schema}.{x.Name}").ToLower(),
            Map = string.Join(",", x.ColNames.Select(x => $"{x}:{GetJsonName(x)}")),
            Params = string.Join(",", x.Params.Where(x => !string.IsNullOrEmpty(x)).OrderBy(x => x).Select(x => $"{x}:")),
        }).Distinct();
    foreach (var proc in procs)
    {
        var parms = (string.IsNullOrEmpty(proc.Params)) ? "" : $"--source.params \"{proc.Params}\"";
#>
dab add "<#=proc.Label#>" --config "dab-config.json" --source "<#=proc.Source#>]" --source.type "stored-procedure" <#=parms#> --rest.methods "post,get" --rest "<#=proc.Rest#>" --permissions "anonymous:execute"
dab update "<#=proc.Label#>" --config "dab-config.json" --map "<#=proc.Map#>"

<# }#><#+

string GetJsonName(string name)
{
    string result = Regex.Replace(name, @"(\p{Lu})", "-$1");
    result = Regex.Replace(result, @"[^\w]", "-");
    result = result.Trim('-', '[', ']', '.', ' ').ToLower().Replace(" ", "-");
    return Regex.Replace(result, @"-+", "-");
}

IEnumerable<(string Schema, string Name, string @Type, string[] Params, string[] ParamSqlTypes, string[] ParamNetTypes, string[] ColNames, string[] ColSqlTypes, string[] ColNetTypes, bool[] ColIsKey, bool[] ColIsComputed)> GetCache(string connectionString)
{
    var connection = new SqlConnection(connectionString);
    connection.Open();

    var command = new SqlCommand(GetSql(), connection);
    using (var reader = command.ExecuteReader(CommandBehavior.CloseConnection))
    {
        while (reader.Read())
        {
            var schema = reader["schema_name"].ToString();
            var name = reader["object_name"].ToString();
            var type = reader["object_type"].ToString();
            var @params = reader["parameter_names"]?.ToString().Split(',');
            var paramSqlTypes = reader["parameter_sql_types"]?.ToString().Split(',');
            var paramNetTypes = reader["parameter_net_types"]?.ToString().Split(',');
            var colNames = reader["column_names"].ToString().Split(',');
            var colSqlTypes = reader["column_sql_types"].ToString().Split(',');
            var colNetTypes = reader["column_net_types"].ToString().Replace("string?", "string").Split(',');
            var colIsKey = reader["primary_key"].ToString().Split(',').Select(x => bool.Parse(x)).ToArray();
            var colIsComputed = reader["is_computed"].ToString().Split(',').Select(x => bool.Parse(x)).ToArray();

            yield return (schema, name, type, @params, paramSqlTypes, paramNetTypes, colNames, colSqlTypes, colNetTypes, colIsKey, colIsComputed);
        }
    }
}

string GetSql() => """
;WITH types AS 
(    
  SELECT DISTINCT system_type_id,  
    CASE   
      WHEN system_type_id IN (34, 35, 99, 173, 165, 167, 175, 231, 239) THEN 'string'    
      WHEN system_type_id IN (36, 189) THEN 'Guid'    
      WHEN system_type_id IN (48) THEN 'byte'    
      WHEN system_type_id IN (52) THEN 'short'   
      WHEN system_type_id IN (56) THEN 'int'
      WHEN system_type_id IN (58, 61) THEN 'DateTime' 
      WHEN system_type_id IN (59, 62, 106, 108, 122) THEN 'decimal'  
      WHEN system_type_id IN (60, 127) THEN 'double'  
      WHEN system_type_id IN (98) THEN 'object'  
      WHEN system_type_id IN (104) THEN 'bool'   
      WHEN system_type_id IN (241) THEN 'Xml'    
      ELSE 'unknown'    
    END AS net_type  
  FROM sys.types  
)    
, procedures AS
(    
  SELECT  
    s.name AS schema_name,  
    p.name AS object_name,  
    STRING_AGG(REPLACE(d.name, '@', ''), ',') AS parameter_names,   
    STRING_AGG(t.name, ',') AS parameter_sql_types,  
    STRING_AGG(CONCAT(ttypes.net_type, CASE WHEN t.is_nullable = 1 THEN '?' END), ',') AS parameter_net_types 
  FROM sys.procedures p  
  JOIN sys.schemas s ON p.schema_id = s.schema_id 
  LEFT JOIN sys.parameters d ON p.object_id = d.object_id AND d.parameter_id > 0
  LEFT JOIN sys.types t ON d.system_type_id = t.system_type_id   
  LEFT JOIN types AS ttypes ON ttypes.system_type_id = t.system_type_id    
  WHERE p.is_ms_shipped = 0   
  GROUP BY s.name, p.name
)    
SELECT    
  p.schema_name,  
  p.object_name,  
  'procedure' AS object_type,  
  p.parameter_names,
  p.parameter_sql_types,
  p.parameter_net_types,
  STRING_AGG(r.name, ',') AS column_names,
  STRING_AGG(TYPE_NAME(r.system_type_id), ',') AS column_sql_types,    
  STRING_AGG(CONCAT(rtypes.net_type, CASE WHEN r.is_nullable = 1 THEN '?' END), ',') AS column_net_types,   
  STRING_AGG('false', ',') AS primary_key,   
  STRING_AGG('true', ',') AS is_computed    
FROM procedures AS p
CROSS APPLY sys.dm_exec_describe_first_result_set(N'EXEC ' + QUOTENAME(p.schema_name) + '.' + QUOTENAME(p.object_name), NULL, 0) AS r 
JOIN types AS rtypes ON rtypes.system_type_id = r.system_type_id 
GROUP BY 
  p.schema_name,  
  p.object_name,  
  p.parameter_names,
  p.parameter_sql_types,
  p.parameter_net_types
 
UNION
    
SELECT
  s.name AS schema_name,
  t.name AS object_name,
  'table' AS object_type,
  NULL, NULL, NULL,
  STRING_AGG(c.name, ',') AS column_names,
  STRING_AGG(TYPE_NAME(c.system_type_id), ',') AS column_sql_types,
  STRING_AGG(CONCAT(ctypes.net_type, CASE WHEN c.is_nullable = 1 THEN '?' END), ',') AS column_net_types,    
  STRING_AGG(CASE WHEN ic.column_id IS NOT NULL THEN 'true' ELSE 'false' END, ',') AS primary_key,
  STRING_AGG(CASE WHEN cc.name IS NOT NULL THEN 'true' ELSE 'false' END, ',') AS is_computed
FROM sys.tables t
JOIN sys.schemas s ON t.schema_id = s.schema_id
JOIN sys.columns c ON t.object_id = c.object_id
JOIN types AS ctypes ON ctypes.system_type_id = c.system_type_id 
LEFT JOIN sys.indexes i ON i.object_id = t.object_id AND i.is_primary_key = 1
LEFT JOIN sys.index_columns ic ON ic.object_id = t.object_id AND ic.index_id = i.index_id AND ic.column_id = c.column_id
LEFT JOIN sys.computed_columns cc ON c.object_id = cc.object_id AND c.column_id = cc.column_id
WHERE c.graph_type IS NULL 
GROUP BY 
  s.name,
  t.name

UNION
 
SELECT    
  s.name AS schema_name,    
  v.name AS object_name,    
  'view' AS object_type,    
  NULL, NULL, NULL,    
  STRING_AGG(c.name, ',') AS column_names,
  STRING_AGG(TYPE_NAME(c.system_type_id), ',') AS column_sql_types,
  STRING_AGG(CONCAT(ctypes.net_type, CASE WHEN c.is_nullable = 1 THEN '?' ELSE '' END), ',') AS column_net_types,    
  STRING_AGG('false', ',') AS primary_key,
  STRING_AGG(CASE WHEN cc.name IS NOT NULL THEN 'true' ELSE 'false' END, ',') AS is_computed
FROM sys.views v    
JOIN sys.schemas s ON v.schema_id = s.schema_id   
JOIN sys.columns c ON v.object_id = c.object_id   
JOIN types AS ctypes ON ctypes.system_type_id = c.system_type_id 
LEFT JOIN sys.key_constraints pkc ON c.object_id = pkc.parent_object_id AND c.column_id = pkc.unique_index_id 
LEFT JOIN sys.computed_columns cc ON c.object_id = cc.object_id AND c.column_id = cc.column_id
GROUP BY 
  s.name,
  v.name 
""";
#>